/**
 * 配列は固定長だが、スライスは可変長である
 * 基本的には配列と同じように宣言するが、配列の長さは指定せず []T 型で表現される
 *
 * スライスは配列への参照のようなものであり、それ自身は一切のデータをもたない（もとの配列の部分列を指し示しているだけ）
 * したがって、スライスを作成する際は、配列のどの部分を切り取るか low, high の境界を指定する必要がある
 *   slice = array[low : high] // 配列の low 番目〜 high-1 番目（high 番目は含まれない）のスライスを作成
 *
 * スライスは配列への参照のようなものであるため、そのゼロ値は、ポインタと同様 nil となる
 */

package main

import "fmt"

func main()  {
	primes := [6]int{2, 3, 5, 7, 11, 13}

	// 配列 primes の 1 〜 4 - 1 (= 3) 番目のスライスを作成
	var s []int = primes[1 : 4] // {3, 5, 7}
	fmt.Println(s)

	// 配列同様、スライスの長さは len 関数で取得できる
	// スライス s は primes[1] 〜 primes[3] のスライスであるため、長さは 3
	fmt.Println(len(s))

	// スライスには容量という概念があり、スライスの最初の要素から数えて、元となる配列の要素数を容量と呼ぶ
	// スライスの容量は cap 関数で取得できる
	// スライス s は primes[1] 〜 のスライスであり、配列 primes の長さは 6 であるため、容量は 6 - 1 = 5 となる
	fmt.Println(cap(s))

	// スライスはもとの配列への参照であるため、スライスに変更を加えるともとの配列にも変更が反映される
	s[0] = 30 // s: {primes[1]: 3, primes[2]: 5, primes[3]: 7} => {primes[1]: 30, primes[2]: 5, primes[3]: 7}
	fmt.Println(s, primes)

	// スライスは長さを持たない配列として宣言することも可能
	// （実際は、宣言された長さの配列を作って、その配列の頭から尾までのスライスを切り取っている）
	// 以下の場合 [3]bool{true, false, true} という配列を（内部的に）作って、その配列の [0 : 3] のスライスを作成していることになる
	r := []bool{true, false, true}
	fmt.Println(r)

	// 配列をスライスするとき、上限値または下限値を省略すると、それらの既定値が使用される
	// 下限の既定値: 0, 上限の既定値: 配列（スライス）の長さ
	fmt.Println(primes[:3]) // = primes[0 : 3] => {2, 30, 5}
	fmt.Println(primes[3:]) // = primes[3 : len(primes)] => {7, 11, 13}

	// スライスは make 関数でも作成することができ、その各要素はゼロ値となる
	//   make(型名, 長さ, 容量)
	a := make([]int, 3) // [3]int{0, 0, 0} という配列に対する [0 : 3] のスライスを作成
	b := make([]int, 0, 3) // 長さ: 0, 容量: 3 のスライスを作成

	fmt.Println(len(a), cap(a))
	fmt.Println(len(b), cap(b))

	// スライスに新しい要素を追加する際は append 関数を使う
	// append 関数は、必要なサイズのスライスを新たに作成し、元のスライスと新規要素を順番に copy する、という挙動をとるため、割と遅い
	a = append(a, 1) // a: {0, 0, 0} => {0, 0, 0, 1}
	fmt.Println(a)

	// なお、スライスから要素を削除する関数は用意されていない
}
