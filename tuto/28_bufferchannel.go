/**
 * チャネルは、 バッファとして配列のような使い方も可能
 * バッファを持つチャネルを初期化するには、 make の２つ目の引数にバッファの長さを与える
 *   ch := make(chan <型名>, <バッファの長さ>)
 *
 * バッファが詰まった時（指定した長さまでデータが入った時）は、チャネルへの送信はブロックされる
 * また、バッファが空の時には、チャネルへの受信がブロックされる
 *
 * 明示的にチャネルへの送信を close することも可能だが、必ず送信側のチャネルを close すること（close したチャネルにデータを送信すると panic が起きる）
 */

package main

import "fmt"

// fibonacci 関数: n までのフィボナッチ数列をチャネルバッファに送信
func fibonacci(n int, c chan int) {
	x, y := 0, 1
	for i := 0; i < n; i++ {
		c <- x // チャネルバッファに x を送信
		x, y = y, x + y
	}
	// チャネルへの送信を終了する
	// 今回の場合 for range ループでチャネルバッファを処理するため、明示的に close する必要がある
	close(c)
}

func main() {
	// 10個のデータを受け入れられるチャネルバッファを作成
	c := make(chan int, 10)

	// チャネルバッファの容量分のフィボナッチ数列を生成（並列実行）
	go fibonacci(cap(c), c)
	// フィボナッチ数列のデータが受信されるたびに、その数値を出力
	for v := range c { // チャネルバッファに対して for range ループを実行
		fmt.Println(v)
	}
}
